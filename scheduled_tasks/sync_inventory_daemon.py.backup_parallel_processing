"""
在庫同期デーモン

定期的にAmazon在庫・価格を取得し、BASEと同期します。

機能:
- キャッシュ検証と差分補完
- 価格同期（キャッシュベース）
- 在庫同期（visibility更新）

使用例:
    # 3時間ごとに同期（デフォルト - ISSUE #005対応）
    python scheduled_tasks/sync_inventory_daemon.py

    # 1時間ごとに同期（短い間隔）
    python scheduled_tasks/sync_inventory_daemon.py --interval 3600

    # 特定プラットフォームのみ
    python scheduled_tasks/sync_inventory_daemon.py --platform base
"""

import sys
from pathlib import Path
import argparse
import os
import msvcrt  # Windows用ファイルロック

# Windows環境でのUTF-8エンコーディング強制設定
if sys.stdout.encoding != 'utf-8':
    try:
        sys.stdout.reconfigure(encoding='utf-8')
        sys.stderr.reconfigure(encoding='utf-8')
    except AttributeError:
        # Python 3.7未満の場合のフォールバック
        import codecs
        sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, 'strict')
        sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer, 'strict')

# パスを追加
sys.path.insert(0, str(Path(__file__).resolve().parent.parent))

from scheduled_tasks.daemon_base import DaemonBase
from inventory.scripts.sync_inventory import InventorySync
from platforms.ebay.scripts.sync_prices import EbayPriceSync


class SyncInventoryDaemon(DaemonBase):
    """
    在庫同期デーモン

    定期的に以下の処理を実行します:
    1. Amazon SP-APIから最新の価格・在庫情報を取得（キャッシュベース）
    2. BASE出品の価格を同期
    3. BASE出品の在庫状況（visibility）を同期
    """

    def __init__(
        self,
        interval_seconds: int = 10800,
        platform: str = 'base',
        dry_run: bool = False
    ):
        """
        Args:
            interval_seconds: 実行間隔（秒）デフォルト: 10800（3時間 - ISSUE #005対応）
            platform: プラットフォーム名（デフォルト: base）
            dry_run: DRY RUNモード（デフォルト: False）
        """
        # ロックファイルで単一インスタンスを保証
        lock_dir = Path(__file__).parent.parent / 'logs'
        lock_dir.mkdir(exist_ok=True)
        self.lock_file_path = lock_dir / 'sync_inventory_daemon.lock'

        print(f"[LOCK] ロックファイル取得試行: {self.lock_file_path} - PID: {os.getpid()}", flush=True)

        try:
            # ロックファイルを開く（存在しない場合は作成）
            self.lock_file = open(self.lock_file_path, 'w')
            # Windows用ファイルロック取得（非ブロッキング）
            msvcrt.locking(self.lock_file.fileno(), msvcrt.LK_NBLCK, 1)
            # ロック成功 - PIDを書き込む
            self.lock_file.write(f"{os.getpid()}\n")
            self.lock_file.flush()
            print(f"[LOCK] ロック取得成功 - PID: {os.getpid()}", flush=True)
        except (IOError, OSError) as e:
            print(f"[LOCK] エラー: 別のインスタンスが既に実行中です", flush=True)
            print(f"[LOCK] ロックファイル: {self.lock_file_path}", flush=True)
            print(f"[LOCK] 詳細: {e}", flush=True)
            print(f"[LOCK] このプロセスを終了します - PID: {os.getpid()}", flush=True)
            sys.exit(1)

        super().__init__(
            name='sync_inventory',
            interval_seconds=interval_seconds,
            max_retries=3,
            retry_delay_seconds=60,
            enable_notifications=False  # デバッグ: 通知を完全に無効化
        )

        self.platform = platform
        self.dry_run = dry_run

        # プラットフォーム別にSyncインスタンスを作成
        if platform == 'base':
            self.sync = InventorySync(dry_run=dry_run)
        elif platform == 'ebay':
            self.ebay_sync = EbayPriceSync()
        else:
            raise ValueError(f"未対応のプラットフォーム: {platform}")

        self.logger.info(f"プラットフォーム: {platform}")
        self.logger.info(f"DRY RUN: {dry_run}")

    def execute_task(self) -> bool:
        """
        在庫同期タスクを実行

        Returns:
            bool: 成功時True、失敗時False
        """
        try:
            # プラットフォームとアカウント情報を明確に表示
            self.logger.info("=" * 70)
            self.logger.info(f"【在庫・価格同期開始】")
            self.logger.info(f"プラットフォーム: {self.platform.upper()}")

            # アクティブアカウント情報を取得・表示
            if self.platform == 'base':
                from platforms.base.accounts.manager import AccountManager
                account_manager = AccountManager()
                accounts = account_manager.get_active_accounts()
                if accounts:
                    self.logger.info(f"処理対象アカウント数: {len(accounts)}件")
                    for account in accounts:
                        self.logger.info(f"  - {account['name']} ({account['id']})")
                else:
                    self.logger.warning("アクティブなアカウントが見つかりません")
            elif self.platform == 'ebay':
                from platforms.ebay.accounts.manager import EbayAccountManager
                account_manager = EbayAccountManager()
                accounts = account_manager.get_active_accounts()
                if accounts:
                    self.logger.info(f"処理対象アカウント数: {len(accounts)}件")
                    for account in accounts:
                        self.logger.info(f"  - {account['name']} ({account['id']})")
                else:
                    self.logger.warning("アクティブなアカウントが見つかりません")

            self.logger.info(f"実行モード: {'DRY RUN' if self.dry_run else '本番実行'}")
            self.logger.info("=" * 70)

            # プラットフォーム別の処理
            if self.platform == 'base':
                # BASE: 統合同期を実行
                stats = self.sync.run_full_sync(platform=self.platform)
            elif self.platform == 'ebay':
                # eBay: 価格同期のみ
                stats = self._execute_ebay_sync()
            else:
                raise ValueError(f"未対応のプラットフォーム: {self.platform}")

            # 統計情報をログに記録
            self.logger.info("")
            self.logger.info("--- 実行結果サマリー ---")
            self.logger.info(f"所要時間: {stats['duration_seconds']:.1f}秒")

            # 価格同期の統計
            price_stats = stats.get('price_sync', {})
            if price_stats:
                self.logger.info(
                    f"価格同期: 処理={price_stats.get('total_listings', 0)}件, "
                    f"更新={price_stats.get('price_updated', 0)}件, "
                    f"エラー={price_stats.get('errors', 0)}件"
                )

            # 在庫同期の統計
            stock_stats = stats.get('stock_sync', {})
            if stock_stats:
                self.logger.info(
                    f"在庫同期: 処理={stock_stats.get('total_products', 0)}件, "
                    f"非公開={stock_stats.get('updated_to_hidden', 0)}件, "
                    f"公開={stock_stats.get('updated_to_public', 0)}件, "
                    f"エラー={stock_stats.get('errors', 0)}件"
                )

            # エラーチェック
            total_errors = (
                price_stats.get('errors', 0) +
                stock_stats.get('errors', 0)
            )

            if total_errors > 0:
                self.logger.warning(f"警告: {total_errors}件のエラーが発生しました")
                # エラーがあっても通知は送信
                self._send_completion_notification(stats, has_errors=True)
                return False

            self.logger.info("在庫同期が正常に完了しました")

            # 完了通知を送信
            self._send_completion_notification(stats, has_errors=False)

            return True

        except Exception as e:
            self.logger.error(f"在庫同期中にエラーが発生しました: {e}", exc_info=True)
            return False

    def _execute_ebay_sync(self) -> dict:
        """
        eBay価格同期を実行

        Returns:
            dict: 統計情報
        """
        import time
        start_time = time.time()

        # eBay価格同期を実行
        price_stats = self.ebay_sync.sync_all_accounts(dry_run=self.dry_run)

        duration = time.time() - start_time

        # 統計情報を整形（BASEと同じ形式に合わせる）
        return {
            'duration_seconds': duration,
            'price_sync': price_stats,
            'stock_sync': {}  # eBayは価格同期のみ
        }

    def _send_completion_notification(self, stats: dict, has_errors: bool):
        """
        完了通知を送信

        Args:
            stats: 統計情報
            has_errors: エラーがあったかどうか
        """
        # レポート用の統計情報を整形
        price_stats = stats.get('price_sync', {})
        stock_stats = stats.get('stock_sync', {})

        report_stats = {
            '所要時間(秒)': stats.get('duration_seconds', 0),
            '価格同期_処理件数': price_stats.get('total_listings', 0),
            '価格同期_更新件数': price_stats.get('price_updated', 0),
            '価格同期_エラー件数': price_stats.get('errors', 0),
            '在庫同期_処理件数': stock_stats.get('total_products', 0),
            '在庫同期_非公開化': stock_stats.get('updated_to_hidden', 0),
            '在庫同期_公開化': stock_stats.get('updated_to_public', 0),
            '在庫同期_エラー件数': stock_stats.get('errors', 0),
        }

        # 完了レポートを送信
        self.send_completion_report(
            task_name=f'{self.platform.upper()} 在庫・価格同期',
            stats=report_stats
        )

    def __del__(self):
        """デストラクタ: ロックファイルをクリーンアップ"""
        try:
            if hasattr(self, 'lock_file'):
                print(f"[LOCK] ロックファイル解放 - PID: {os.getpid()}", flush=True)
                self.lock_file.close()
            if hasattr(self, 'lock_file_path') and self.lock_file_path.exists():
                self.lock_file_path.unlink()
                print(f"[LOCK] ロックファイル削除: {self.lock_file_path}", flush=True)
        except Exception as e:
            print(f"[LOCK] クリーンアップ中にエラー: {e}", flush=True)


def main():
    """メイン関数"""
    parser = argparse.ArgumentParser(
        description='在庫同期デーモン - 定期的にAmazon在庫・価格をBASEと同期'
    )
    parser.add_argument(
        '--interval',
        type=int,
        default=10800,
        help='実行間隔（秒）デフォルト: 10800（3時間 - ISSUE #005対応）'
    )
    parser.add_argument(
        '--platform',
        type=str,
        default='base',
        help='プラットフォーム名（デフォルト: base）'
    )
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='DRY RUNモード（実際の更新は行わない）'
    )

    args = parser.parse_args()

    # デーモンを作成して実行
    daemon = SyncInventoryDaemon(
        interval_seconds=args.interval,
        platform=args.platform,
        dry_run=args.dry_run
    )

    daemon.run()


if __name__ == '__main__':
    main()
